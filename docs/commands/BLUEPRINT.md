# Blueprint Command

Generate infrastructure-as-code templates from disk images, enabling automated reconstruction and deployment.

## Features

- **Terraform Templates**: Generate AWS, Azure, and GCP configurations
- **Ansible Playbooks**: Create declarative configuration management playbooks
- **Kubernetes Manifests**: Generate complete K8s deployment configurations
- **Docker Compose**: Build multi-service compose files with dependencies
- **Smart Detection**: Automatically identify services, ports, and volumes
- **Cloud-Ready**: Export configurations optimized for cloud deployment

## Usage

### Generate Terraform Template (AWS)

```bash
guestctl blueprint fedora.qcow2 --format terraform --output main.tf
```

### Terraform for Azure

```bash
guestctl blueprint ubuntu.img --format terraform --provider azure --output azure.tf
```

### Terraform for GCP

```bash
guestctl blueprint debian.qcow2 --format terraform --provider gcp --output gcp.tf
```

### Generate Ansible Playbook

```bash
guestctl blueprint centos.img --format ansible --output playbook.yml
```

### Generate Kubernetes Manifests

```bash
guestctl blueprint app.qcow2 --format kubernetes --output deployment.yaml
```

### Generate Docker Compose

```bash
guestctl blueprint webapp.img --format compose --output docker-compose.yml
```

### Verbose Output

```bash
guestctl blueprint image.qcow2 --format terraform --verbose
```

## Output Formats

### Terraform (AWS)

```hcl
# Generated by guestkit blueprint

terraform {
  required_version = ">= 1.0"
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.region
}

variable "region" {
  description = "AWS region"
  type        = string
  default     = "us-east-1"
}

variable "instance_type" {
  description = "EC2 instance type"
  type        = string
  default     = "t3.small"
}

resource "aws_security_group" "main" {
  name        = "webapp-sg"
  description = "Security group for webapp"

  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
    description = "Allow SSH traffic"
  }

  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
    description = "Allow HTTP traffic"
  }

  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
    description = "Allow HTTPS traffic"
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

resource "aws_ebs_volume" "data_0" {
  availability_zone = data.aws_availability_zones.available.names[0]
  size              = 10
  type              = "gp3"

  tags = {
    Name = "webapp-data-0"
    Path = "/var/www"
  }
}

resource "aws_instance" "main" {
  ami           = var.ami_id  # Use your custom AMI
  instance_type = var.instance_type

  vpc_security_group_ids = [aws_security_group.main.id]

  tags = {
    Name = "webapp"
    OS   = "Ubuntu 22.04"
  }
}

resource "aws_volume_attachment" "data_0" {
  device_name = "/dev/sdf"
  volume_id   = aws_ebs_volume.data_0.id
  instance_id = aws_instance.main.id
}

output "instance_id" {
  value = aws_instance.main.id
}

output "public_ip" {
  value = aws_instance.main.public_ip
}

data "aws_availability_zones" "available" {
  state = "available"
}
```

### Ansible Playbook

```yaml
---
# Generated by guestkit blueprint
# Source: Ubuntu 22.04

- name: Configure server
  hosts: all
  become: yes

  vars:
    hostname: webapp

  tasks:
    - name: Set hostname
      hostname:
        name: "{{ hostname }}"

    - name: Install packages
      apt:
        name:
          - nginx
          - python3
          - curl
          - git
        state: present
        update_cache: yes

    - name: Configure nginx service
      systemd:
        name: nginx
        enabled: yes
        state: active

    - name: Configure firewall
      firewalld:
        port: "{{ item }}"
        permanent: yes
        state: enabled
      loop:
        - 22/tcp
        - 80/tcp
        - 443/tcp
      when: ansible_os_family == "RedHat"

    - name: Create data directory /var/www
      file:
        path: /var/www
        state: directory
        mode: '0755'

  handlers:
    - name: restart nginx
      systemd:
        name: nginx
        state: restarted
```

### Kubernetes Manifests

```yaml
---
# Generated by guestkit blueprint
apiVersion: v1
kind: Namespace
metadata:
  name: webapp

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: webapp-config
  namespace: webapp
data:
  hostname: webapp
  os_name: "Ubuntu"
  os_version: "22.04"

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: webapp-data-0
  namespace: webapp
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp
  namespace: webapp
spec:
  replicas: 1
  selector:
    matchLabels:
      app: webapp
  template:
    metadata:
      labels:
        app: webapp
    spec:
      containers:
      - name: webapp
        image: your-registry/image:latest
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 80
          protocol: TCP
        - containerPort: 443
          protocol: TCP
        volumeMounts:
        - name: data-0
          mountPath: /var/www
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        envFrom:
        - configMapRef:
            name: webapp-config
      volumes:
      - name: data-0
        persistentVolumeClaim:
          claimName: webapp-data-0

---
apiVersion: v1
kind: Service
metadata:
  name: webapp
  namespace: webapp
spec:
  selector:
    app: webapp
  ports:
  - name: http
    port: 80
    targetPort: 80
    protocol: TCP
  - name: https
    port: 443
    targetPort: 443
    protocol: TCP
  type: LoadBalancer

---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: webapp
  namespace: webapp
  annotations:
    kubernetes.io/ingress.class: nginx
spec:
  rules:
  - host: webapp.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: webapp
            port:
              number: 80
```

### Docker Compose

```yaml
# Generated by guestkit blueprint
version: '3.8'

services:
  webapp:
    image: your-registry/image:latest
    container_name: webapp
    hostname: webapp
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - 0_data:/var/www:rw
    environment:
      - HOSTNAME=webapp
      - OS_NAME=Ubuntu
      - OS_VERSION=22.04
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M
    restart: unless-stopped
    networks:
      - app_network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:80"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

volumes:
  0_data:

networks:
  app_network:
    driver: bridge
```

## Detected Components

### Services

The blueprint command automatically detects:

- **Web Servers**: nginx, apache2, httpd
- **Databases**: mysql, mariadb, postgresql, redis
- **Container Runtimes**: docker
- **System Services**: SSH (sshd)

### Ports

Automatically exposed based on detected services:

| Port | Service | Description |
|------|---------|-------------|
| 22 | SSH | Secure Shell |
| 80 | HTTP | Web traffic |
| 443 | HTTPS | Secure web traffic |
| 3306 | MySQL | MySQL database |
| 5432 | PostgreSQL | PostgreSQL database |
| 6379 | Redis | Redis cache |

### Volumes

Data directories automatically configured:

- `/var/lib/mysql` - MySQL data
- `/var/lib/postgresql` - PostgreSQL data
- `/var/lib/redis` - Redis data
- `/var/www` - Web content
- `/opt` - Optional software
- `/srv` - Service data

## Cloud Provider Features

### AWS Terraform

- **EC2 Instances**: Right-sized based on detected workload
- **Security Groups**: Configured for detected ports
- **EBS Volumes**: Mapped to data directories
- **Auto Scaling**: Ready for ASG configuration
- **Tags**: Automatic resource tagging

Instance type selection:
- `t3.micro` - Basic workloads
- `t3.small` - Web servers
- `t3.medium` - Database servers

### Azure Terraform

- **Virtual Machines**: Configured for workload
- **Resource Groups**: Organized resources
- **Virtual Networks**: Network isolation
- **Managed Disks**: Persistent storage
- **Network Security Groups**: Port rules

### GCP Terraform

- **Compute Instances**: Right-sized VMs
- **Persistent Disks**: Volume mapping
- **VPC Networks**: Network configuration
- **Firewall Rules**: Port configuration
- **Instance Groups**: Scalability ready

## Workflows

### 1. VM to Cloud Migration

```bash
# Step 1: Analyze the VM
guestctl blueprint prod-vm.qcow2 --format terraform --provider aws --verbose

# Step 2: Generate Terraform
guestctl blueprint prod-vm.qcow2 --format terraform --provider aws --output main.tf

# Step 3: Review and customize
vi main.tf

# Step 4: Deploy
terraform init
terraform plan
terraform apply
```

### 2. Container Migration

```bash
# Step 1: Generate Docker Compose
guestctl blueprint app-vm.qcow2 --format compose --output docker-compose.yml

# Step 2: Build container image (manual step)
# Convert VM to container using containerization tools

# Step 3: Update compose file with image name
sed -i 's/your-registry\/image:latest/myapp:v1/' docker-compose.yml

# Step 4: Deploy
docker-compose up -d
```

### 3. Kubernetes Deployment

```bash
# Step 1: Generate manifests
guestctl blueprint app.qcow2 --format kubernetes --output k8s.yaml

# Step 2: Customize image and domain
sed -i 's/your-registry\/image:latest/gcr.io\/myproject\/app:v1/' k8s.yaml
sed -i 's/webapp.example.com/app.mydomain.com/' k8s.yaml

# Step 3: Apply to cluster
kubectl apply -f k8s.yaml

# Step 4: Verify deployment
kubectl get pods -n webapp
kubectl get svc -n webapp
```

### 4. Configuration Management

```bash
# Step 1: Generate Ansible playbook
guestctl blueprint server.qcow2 --format ansible --output playbook.yml

# Step 2: Create inventory
cat > inventory <<EOF
[servers]
server1 ansible_host=192.168.1.10
server2 ansible_host=192.168.1.11
EOF

# Step 3: Run playbook
ansible-playbook -i inventory playbook.yml
```

## CI/CD Integration

### GitHub Actions

```yaml
name: Generate Infrastructure

on:
  push:
    paths:
      - 'images/**'

jobs:
  blueprint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2

      - name: Generate Terraform
        run: |
          guestctl blueprint images/prod.qcow2 \
            --format terraform \
            --provider aws \
            --output terraform/main.tf

      - name: Validate Terraform
        run: |
          cd terraform
          terraform init
          terraform validate

      - name: Create PR
        uses: peter-evans/create-pull-request@v4
        with:
          title: "Update infrastructure from image"
          body: "Auto-generated from disk image analysis"
```

### GitLab CI

```yaml
generate-blueprint:
  stage: build
  script:
    - guestctl blueprint $VM_IMAGE --format terraform --output main.tf
    - terraform fmt main.tf
  artifacts:
    paths:
      - main.tf
    expire_in: 1 week
```

## Best Practices

### 1. Review Generated Code

Always review and customize generated templates:

```bash
# Generate blueprint
guestctl blueprint vm.qcow2 --format terraform --output main.tf

# Review carefully
less main.tf

# Customize for your needs
vi main.tf
```

### 2. Use Variables

Parameterize deployment-specific values:

```hcl
# Instead of hardcoded
ami = "ami-12345"

# Use variable
ami = var.ami_id
```

### 3. Security Hardening

Tighten security group rules:

```hcl
# Generated (open)
cidr_blocks = ["0.0.0.0/0"]

# Hardened (restricted)
cidr_blocks = ["10.0.0.0/8"]
```

### 4. Tag Resources

Add comprehensive tagging:

```hcl
tags = {
  Name        = "webapp"
  Environment = "production"
  ManagedBy   = "terraform"
  CostCenter  = "engineering"
  Owner       = "team@company.com"
}
```

### 5. State Management

Use remote state for Terraform:

```hcl
terraform {
  backend "s3" {
    bucket = "terraform-state"
    key    = "webapp/terraform.tfstate"
    region = "us-east-1"
  }
}
```

## Customization

### Modify Instance Types

```bash
# Generate baseline
guestctl blueprint vm.qcow2 --format terraform --output main.tf

# Update instance type
sed -i 's/t3.micro/t3.large/' main.tf
```

### Add Load Balancer

Extend generated Terraform:

```hcl
resource "aws_lb" "main" {
  name               = "webapp-lb"
  internal           = false
  load_balancer_type = "application"
  security_groups    = [aws_security_group.main.id]
  subnets            = var.subnet_ids
}
```

### Configure Autoscaling

Add ASG to generated config:

```hcl
resource "aws_autoscaling_group" "main" {
  name                = "webapp-asg"
  vpc_zone_identifier = var.subnet_ids
  min_size            = 1
  max_size            = 10
  desired_capacity    = 2

  launch_template {
    id      = aws_launch_template.main.id
    version = "$Latest"
  }
}
```

## Troubleshooting

### Issue: "No operating system found"

```bash
# Verify image is valid
guestctl inspect vm.qcow2

# Try different format
qemu-img convert vm.vmdk vm.qcow2
guestctl blueprint vm.qcow2 --format terraform
```

### Issue: Missing services

The blueprint generator detects common services. For custom services:

```bash
# Generate baseline
guestctl blueprint vm.qcow2 --format ansible --output playbook.yml

# Manually add your service
vi playbook.yml
```

### Issue: Port detection incomplete

Add ports manually to generated config:

```hcl
# In security group
ingress {
  from_port   = 8080
  to_port     = 8080
  protocol    = "tcp"
  cidr_blocks = ["0.0.0.0/0"]
}
```

## Limitations

### Current Limitations

1. **Static Analysis**: Analyzes image at rest, not runtime behavior
2. **Service Detection**: Limited to common services with standard paths
3. **Configuration**: Cannot extract complex application configuration
4. **State**: Does not capture application state or data
5. **Dependencies**: May not detect all inter-service dependencies

### Manual Steps Required

1. **Container Images**: VM â†’ container conversion must be done separately
2. **AMI/Image**: Must upload disk image to cloud provider
3. **Secrets**: Must configure secrets management separately
4. **DNS**: Must configure DNS records
5. **SSL/TLS**: Must provision certificates

## Advanced Usage

### Combine with Inventory

```bash
# Generate SBOM
guestctl inventory vm.qcow2 --format spdx --output sbom.json

# Generate blueprint
guestctl blueprint vm.qcow2 --format terraform --output main.tf

# Use SBOM data to tag resources
```

### Multi-Region Deployment

```bash
# Generate for each region
for region in us-east-1 us-west-2 eu-west-1; do
  guestctl blueprint vm.qcow2 \
    --format terraform \
    --provider aws \
    --output ${region}.tf

  # Customize region
  sed -i "s/us-east-1/${region}/" ${region}.tf
done
```

### Blue-Green Deployment

```bash
# Generate blue environment
guestctl blueprint vm.qcow2 --format terraform --output blue.tf

# Generate green environment
guestctl blueprint vm.qcow2 --format terraform --output green.tf

# Update tags
sed -i 's/Environment = "production"/Environment = "blue"/' blue.tf
sed -i 's/Environment = "production"/Environment = "green"/' green.tf
```

## See Also

- [Inventory Command](INVENTORY.md) - Generate SBOM
- [Validate Command](VALIDATE.md) - Policy validation
- [License Command](LICENSE.md) - License compliance
- [Terraform Documentation](https://www.terraform.io/)
- [Ansible Documentation](https://docs.ansible.com/)
- [Kubernetes Documentation](https://kubernetes.io/docs/)
- [Docker Compose Documentation](https://docs.docker.com/compose/)
