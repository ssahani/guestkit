// SPDX-License-Identifier: LGPL-3.0-or-later
//! Plan export to various formats (bash, ansible, terraform)

use super::types::*;
use anyhow::Result;
use std::fmt::Write as FmtWrite;

/// Exports fix plans to different formats
pub struct PlanExporter;

impl PlanExporter {
    /// Export plan as bash script
    pub fn to_bash(plan: &FixPlan) -> Result<String> {
        let mut script = String::new();

        writeln!(script, "#!/bin/bash")?;
        writeln!(script, "# Generated by GuestKit v0.3.1")?;
        writeln!(script, "# Profile: {}", plan.profile)?;
        writeln!(script, "# VM: {}", plan.vm)?;
        writeln!(script, "# Generated: {}", plan.generated)?;
        writeln!(script)?;
        writeln!(script, "set -e")?;
        writeln!(script)?;
        writeln!(script, "echo \"Applying {} fixes...\"", plan.profile)?;
        writeln!(script)?;

        // Backup section
        writeln!(script, "# Create backup")?;
        writeln!(script, "BACKUP_DIR=\"/backup/$(date +%Y%m%d-%H%M%S)\"")?;
        writeln!(script, "mkdir -p \"$BACKUP_DIR\"")?;
        writeln!(script)?;

        // Generate operations
        for op in &plan.operations {
            Self::operation_to_bash(&mut script, op)?;
        }

        // Post-apply actions
        if !plan.post_apply.is_empty() {
            writeln!(script, "# Post-apply actions")?;
            for action in &plan.post_apply {
                Self::post_action_to_bash(&mut script, action)?;
            }
        }

        writeln!(script)?;
        writeln!(script, "echo \"✓ All fixes applied successfully\"")?;

        Ok(script)
    }

    /// Convert operation to bash commands
    fn operation_to_bash(script: &mut String, op: &Operation) -> Result<()> {
        writeln!(script, "# {}: {}", op.id, op.description)?;

        match &op.op_type {
            OperationType::FileEdit(fe) => {
                writeln!(script, "cp \"{}\" \"$BACKUP_DIR/\"", fe.file)?;
                for change in &fe.changes {
                    writeln!(
                        script,
                        "sed -i 's/{}/{}/g' \"{}\"",
                        change.before.replace('/', "\\/"),
                        change.after.replace('/', "\\/"),
                        fe.file
                    )?;
                }
            }
            OperationType::PackageInstall(pi) => {
                writeln!(script, "dnf install -y {}", pi.packages.join(" "))?;
            }
            OperationType::ServiceOperation(so) => {
                if let Some(state) = &so.state {
                    if state == "enabled" {
                        writeln!(script, "systemctl enable {}", so.service)?;
                    }
                }
                if so.start {
                    writeln!(script, "systemctl start {}", so.service)?;
                }
                if so.restart {
                    writeln!(script, "systemctl restart {}", so.service)?;
                }
            }
            OperationType::SelinuxMode(sm) => {
                writeln!(
                    script,
                    "sed -i 's/SELINUX={}/SELINUX={}/g' \"{}\"",
                    sm.current, sm.target, sm.file
                )?;
            }
            OperationType::CommandExec(ce) => {
                writeln!(script, "{}", ce.command)?;
            }
            OperationType::FileCopy(fc) => {
                writeln!(script, "cp \"{}\" \"{}\"", fc.source, fc.destination)?;
            }
            OperationType::DirectoryCreate(dc) => {
                if let Some(mode) = &dc.mode {
                    writeln!(script, "mkdir -p -m {} \"{}\"", mode, dc.path)?;
                } else {
                    writeln!(script, "mkdir -p \"{}\"", dc.path)?;
                }
            }
            OperationType::FilePermissions(fp) => {
                writeln!(script, "chmod {} \"{}\"", fp.mode, fp.path)?;
                if let Some(owner) = &fp.owner {
                    writeln!(script, "chown {} \"{}\"", owner, fp.path)?;
                }
            }
            _ => {
                writeln!(script, "# TODO: {} not implemented in bash export", op.id)?;
            }
        }

        if let Some(validation) = &op.validation {
            writeln!(script, "{} || {{ echo \"Validation failed for {}\"; exit 1; }}",
                validation.command, op.id)?;
        }

        writeln!(script)?;
        Ok(())
    }

    /// Convert post-apply action to bash
    fn post_action_to_bash(script: &mut String, action: &PostApplyAction) -> Result<()> {
        match action {
            PostApplyAction::ServiceRestart { services } => {
                for service in services {
                    writeln!(script, "systemctl restart {}", service)?;
                }
            }
            PostApplyAction::Validation { command, .. } => {
                writeln!(script, "{}", command)?;
            }
            PostApplyAction::Message { message } => {
                writeln!(script, "echo \"{}\"", message)?;
            }
            PostApplyAction::RebootRequired { reason } => {
                writeln!(script, "echo \"⚠️  Reboot required: {}\"", reason)?;
            }
        }
        Ok(())
    }

    /// Export plan as Ansible playbook
    pub fn to_ansible(plan: &FixPlan) -> Result<String> {
        let mut playbook = String::new();

        writeln!(playbook, "---")?;
        writeln!(playbook, "- name: GuestKit {} Fixes", plan.profile)?;
        writeln!(playbook, "  hosts: vm")?;
        writeln!(playbook, "  become: yes")?;
        writeln!(playbook, "  tasks:")?;

        for op in &plan.operations {
            Self::operation_to_ansible(&mut playbook, op)?;
        }

        Ok(playbook)
    }

    /// Convert operation to Ansible task
    fn operation_to_ansible(playbook: &mut String, op: &Operation) -> Result<()> {
        writeln!(playbook, "    - name: {}", op.description)?;

        match &op.op_type {
            OperationType::FileEdit(fe) => {
                if let Some(change) = fe.changes.first() {
                    writeln!(playbook, "      lineinfile:")?;
                    writeln!(playbook, "        path: {}", fe.file)?;
                    writeln!(playbook, "        regexp: '^{}$'", change.before)?;
                    writeln!(playbook, "        line: '{}'", change.after)?;
                    writeln!(playbook, "        backup: yes")?;
                }
            }
            OperationType::PackageInstall(pi) => {
                writeln!(playbook, "      package:")?;
                writeln!(playbook, "        name:")?;
                for pkg in &pi.packages {
                    writeln!(playbook, "          - {}", pkg)?;
                }
                writeln!(playbook, "        state: present")?;
            }
            OperationType::ServiceOperation(so) => {
                writeln!(playbook, "      service:")?;
                writeln!(playbook, "        name: {}", so.service)?;
                if let Some(state) = &so.state {
                    writeln!(playbook, "        enabled: {}", state == "enabled")?;
                }
                if so.start {
                    writeln!(playbook, "        state: started")?;
                }
            }
            _ => {
                writeln!(playbook, "      # TODO: Ansible task for {}", op.id)?;
            }
        }

        writeln!(playbook)?;
        Ok(())
    }

    /// Export plan as JSON
    pub fn to_json(plan: &FixPlan) -> Result<String> {
        Ok(serde_json::to_string_pretty(plan)?)
    }

    /// Export plan as YAML
    pub fn to_yaml(plan: &FixPlan) -> Result<String> {
        Ok(serde_yaml::to_string(plan)?)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_bash_export() {
        let plan = FixPlan::new("test.qcow2".to_string(), "security".to_string());
        let script = PlanExporter::to_bash(&plan).unwrap();
        assert!(script.contains("#!/bin/bash"));
        assert!(script.contains("GuestKit"));
    }

    #[test]
    fn test_json_export() {
        let plan = FixPlan::new("test.qcow2".to_string(), "security".to_string());
        let json = PlanExporter::to_json(&plan).unwrap();
        assert!(json.contains("security"));
    }
}
