// SPDX-License-Identifier: LGPL-3.0-or-later
//! Terraform template generation

use super::ImageAnalysis;
use anyhow::Result;

/// Generate Terraform configuration
pub fn generate(analysis: &ImageAnalysis, provider: Option<&str>) -> Result<String> {
    let provider = provider.unwrap_or("aws");

    match provider {
        "aws" => generate_aws(analysis),
        "azure" => generate_azure(analysis),
        "gcp" => generate_gcp(analysis),
        _ => generate_aws(analysis),
    }
}

fn generate_aws(analysis: &ImageAnalysis) -> Result<String> {
    let mut tf = String::new();

    // Provider configuration
    tf.push_str("# Generated by guestkit blueprint\n\n");
    tf.push_str("terraform {\n");
    tf.push_str("  required_version = \">= 1.0\"\n");
    tf.push_str("  required_providers {\n");
    tf.push_str("    aws = {\n");
    tf.push_str("      source  = \"hashicorp/aws\"\n");
    tf.push_str("      version = \"~> 5.0\"\n");
    tf.push_str("    }\n");
    tf.push_str("  }\n");
    tf.push_str("}\n\n");

    tf.push_str("provider \"aws\" {\n");
    tf.push_str("  region = var.region\n");
    tf.push_str("}\n\n");

    // Variables
    tf.push_str("variable \"region\" {\n");
    tf.push_str("  description = \"AWS region\"\n");
    tf.push_str("  type        = string\n");
    tf.push_str("  default     = \"us-east-1\"\n");
    tf.push_str("}\n\n");

    tf.push_str("variable \"instance_type\" {\n");
    tf.push_str("  description = \"EC2 instance type\"\n");
    tf.push_str("  type        = string\n");
    tf.push_str(&format!("  default     = \"{}\"\n", suggest_instance_type(analysis)));
    tf.push_str("}\n\n");

    // Security group
    tf.push_str("resource \"aws_security_group\" \"main\" {\n");
    tf.push_str(&format!("  name        = \"{}-sg\"\n", sanitize_name(&analysis.hostname)));
    tf.push_str(&format!("  description = \"Security group for {}\"\n", analysis.hostname));
    tf.push_str("\n");

    // Ingress rules based on detected ports
    for port in &analysis.ports {
        tf.push_str("  ingress {\n");
        tf.push_str(&format!("    from_port   = {}\n", port.number));
        tf.push_str(&format!("    to_port     = {}\n", port.number));
        tf.push_str(&format!("    protocol    = \"{}\"\n", port.protocol));
        tf.push_str("    cidr_blocks = [\"0.0.0.0/0\"]\n");
        tf.push_str(&format!("    description = \"Allow {} traffic\"\n",
            match port.number {
                22 => "SSH",
                80 => "HTTP",
                443 => "HTTPS",
                3306 => "MySQL",
                5432 => "PostgreSQL",
                6379 => "Redis",
                _ => "Custom",
            }));
        tf.push_str("  }\n\n");
    }

    tf.push_str("  egress {\n");
    tf.push_str("    from_port   = 0\n");
    tf.push_str("    to_port     = 0\n");
    tf.push_str("    protocol    = \"-1\"\n");
    tf.push_str("    cidr_blocks = [\"0.0.0.0/0\"]\n");
    tf.push_str("  }\n");
    tf.push_str("}\n\n");

    // EBS volumes for detected data volumes
    for (idx, volume) in analysis.volumes.iter().enumerate() {
        tf.push_str(&format!("resource \"aws_ebs_volume\" \"data_{}\" {{\n", idx));
        tf.push_str("  availability_zone = data.aws_availability_zones.available.names[0]\n");
        tf.push_str(&format!("  size              = {}\n", volume.size_gb.ceil() as u64));
        tf.push_str("  type              = \"gp3\"\n");
        tf.push_str("\n");
        tf.push_str("  tags = {\n");
        tf.push_str(&format!("    Name = \"{}-data-{}\"\n", sanitize_name(&analysis.hostname), idx));
        tf.push_str(&format!("    Path = \"{}\"\n", volume.path));
        tf.push_str("  }\n");
        tf.push_str("}\n\n");
    }

    // EC2 instance
    tf.push_str("resource \"aws_instance\" \"main\" {\n");
    tf.push_str("  ami           = var.ami_id  # Use your custom AMI\n");
    tf.push_str("  instance_type = var.instance_type\n");
    tf.push_str("\n");
    tf.push_str("  vpc_security_group_ids = [aws_security_group.main.id]\n");
    tf.push_str("\n");
    tf.push_str("  tags = {\n");
    tf.push_str(&format!("    Name = \"{}\"\n", sanitize_name(&analysis.hostname)));
    tf.push_str(&format!("    OS   = \"{} {}\"\n", analysis.os_name, analysis.os_version));
    tf.push_str("  }\n");
    tf.push_str("}\n\n");

    // Volume attachments
    for (idx, _volume) in analysis.volumes.iter().enumerate() {
        tf.push_str(&format!("resource \"aws_volume_attachment\" \"data_{}\" {{\n", idx));
        tf.push_str(&format!("  device_name = \"/dev/sd{}\"\n",
            char::from_u32('f' as u32 + idx as u32).unwrap_or('f')));
        tf.push_str(&format!("  volume_id   = aws_ebs_volume.data_{}.id\n", idx));
        tf.push_str("  instance_id = aws_instance.main.id\n");
        tf.push_str("}\n\n");
    }

    // Outputs
    tf.push_str("output \"instance_id\" {\n");
    tf.push_str("  value = aws_instance.main.id\n");
    tf.push_str("}\n\n");

    tf.push_str("output \"public_ip\" {\n");
    tf.push_str("  value = aws_instance.main.public_ip\n");
    tf.push_str("}\n\n");

    tf.push_str("data \"aws_availability_zones\" \"available\" {\n");
    tf.push_str("  state = \"available\"\n");
    tf.push_str("}\n");

    Ok(tf)
}

fn generate_azure(analysis: &ImageAnalysis) -> Result<String> {
    let mut tf = String::new();

    tf.push_str("# Generated by guestkit blueprint - Azure\n\n");
    tf.push_str("terraform {\n");
    tf.push_str("  required_providers {\n");
    tf.push_str("    azurerm = {\n");
    tf.push_str("      source  = \"hashicorp/azurerm\"\n");
    tf.push_str("      version = \"~> 3.0\"\n");
    tf.push_str("    }\n");
    tf.push_str("  }\n");
    tf.push_str("}\n\n");

    tf.push_str("provider \"azurerm\" {\n");
    tf.push_str("  features {}\n");
    tf.push_str("}\n\n");

    tf.push_str("resource \"azurerm_resource_group\" \"main\" {\n");
    tf.push_str(&format!("  name     = \"{}-rg\"\n", sanitize_name(&analysis.hostname)));
    tf.push_str("  location = var.location\n");
    tf.push_str("}\n\n");

    tf.push_str("resource \"azurerm_virtual_network\" \"main\" {\n");
    tf.push_str(&format!("  name                = \"{}-vnet\"\n", sanitize_name(&analysis.hostname)));
    tf.push_str("  address_space       = [\"10.0.0.0/16\"]\n");
    tf.push_str("  location            = azurerm_resource_group.main.location\n");
    tf.push_str("  resource_group_name = azurerm_resource_group.main.name\n");
    tf.push_str("}\n");

    Ok(tf)
}

fn generate_gcp(analysis: &ImageAnalysis) -> Result<String> {
    let mut tf = String::new();

    tf.push_str("# Generated by guestkit blueprint - GCP\n\n");
    tf.push_str("terraform {\n");
    tf.push_str("  required_providers {\n");
    tf.push_str("    google = {\n");
    tf.push_str("      source  = \"hashicorp/google\"\n");
    tf.push_str("      version = \"~> 5.0\"\n");
    tf.push_str("    }\n");
    tf.push_str("  }\n");
    tf.push_str("}\n\n");

    tf.push_str("provider \"google\" {\n");
    tf.push_str("  project = var.project_id\n");
    tf.push_str("  region  = var.region\n");
    tf.push_str("}\n\n");

    tf.push_str("resource \"google_compute_instance\" \"main\" {\n");
    tf.push_str(&format!("  name         = \"{}\"\n", sanitize_name(&analysis.hostname)));
    tf.push_str("  machine_type = var.machine_type\n");
    tf.push_str("  zone         = var.zone\n");
    tf.push_str("\n");
    tf.push_str("  boot_disk {\n");
    tf.push_str("    initialize_params {\n");
    tf.push_str("      image = var.image\n");
    tf.push_str("    }\n");
    tf.push_str("  }\n");
    tf.push_str("}\n");

    Ok(tf)
}

fn suggest_instance_type(analysis: &ImageAnalysis) -> &'static str {
    // Simple heuristic based on detected services
    let has_database = analysis.services.iter()
        .any(|s| s.name.contains("mysql") || s.name.contains("postgresql"));

    let has_web = analysis.services.iter()
        .any(|s| s.name.contains("nginx") || s.name.contains("apache") || s.name.contains("httpd"));

    if has_database {
        "t3.medium"  // Database needs more resources
    } else if has_web {
        "t3.small"   // Web server
    } else {
        "t3.micro"   // Default minimal
    }
}

fn sanitize_name(name: &str) -> String {
    name.to_lowercase()
        .chars()
        .map(|c| if c.is_alphanumeric() || c == '-' { c } else { '-' })
        .collect()
}
