// SPDX-License-Identifier: LGPL-3.0-or-later
//! Kubernetes manifest generation

use super::ImageAnalysis;
use anyhow::Result;

/// Generate Kubernetes manifests
pub fn generate(analysis: &ImageAnalysis) -> Result<String> {
    let mut manifests = String::new();

    let app_name = sanitize_name(&analysis.hostname);

    // Namespace
    manifests.push_str("---\n");
    manifests.push_str("# Generated by guestkit blueprint\n");
    manifests.push_str("apiVersion: v1\n");
    manifests.push_str("kind: Namespace\n");
    manifests.push_str("metadata:\n");
    manifests.push_str(&format!("  name: {}\n", app_name));
    manifests.push_str("\n");

    // ConfigMap
    manifests.push_str("---\n");
    manifests.push_str("apiVersion: v1\n");
    manifests.push_str("kind: ConfigMap\n");
    manifests.push_str("metadata:\n");
    manifests.push_str(&format!("  name: {}-config\n", app_name));
    manifests.push_str(&format!("  namespace: {}\n", app_name));
    manifests.push_str("data:\n");
    manifests.push_str(&format!("  hostname: {}\n", analysis.hostname));
    manifests.push_str(&format!("  os_name: \"{}\"\n", analysis.os_name));
    manifests.push_str(&format!("  os_version: \"{}\"\n", analysis.os_version));
    manifests.push_str("\n");

    // PersistentVolumeClaims for volumes
    for (idx, volume) in analysis.volumes.iter().enumerate() {
        manifests.push_str("---\n");
        manifests.push_str("apiVersion: v1\n");
        manifests.push_str("kind: PersistentVolumeClaim\n");
        manifests.push_str("metadata:\n");
        manifests.push_str(&format!("  name: {}-data-{}\n", app_name, idx));
        manifests.push_str(&format!("  namespace: {}\n", app_name));
        manifests.push_str("spec:\n");
        manifests.push_str("  accessModes:\n");
        manifests.push_str("    - ReadWriteOnce\n");
        manifests.push_str("  resources:\n");
        manifests.push_str("    requests:\n");
        manifests.push_str(&format!("      storage: {}Gi\n", volume.size_gb.ceil() as u64));
        manifests.push_str("\n");
    }

    // Deployment
    manifests.push_str("---\n");
    manifests.push_str("apiVersion: apps/v1\n");
    manifests.push_str("kind: Deployment\n");
    manifests.push_str("metadata:\n");
    manifests.push_str(&format!("  name: {}\n", app_name));
    manifests.push_str(&format!("  namespace: {}\n", app_name));
    manifests.push_str("spec:\n");
    manifests.push_str("  replicas: 1\n");
    manifests.push_str("  selector:\n");
    manifests.push_str("    matchLabels:\n");
    manifests.push_str(&format!("      app: {}\n", app_name));
    manifests.push_str("  template:\n");
    manifests.push_str("    metadata:\n");
    manifests.push_str("      labels:\n");
    manifests.push_str(&format!("        app: {}\n", app_name));
    manifests.push_str("    spec:\n");
    manifests.push_str("      containers:\n");
    manifests.push_str(&format!("      - name: {}\n", app_name));
    manifests.push_str("        image: your-registry/image:latest  # Replace with your image\n");
    manifests.push_str("        imagePullPolicy: IfNotPresent\n");

    // Ports
    if !analysis.ports.is_empty() {
        manifests.push_str("        ports:\n");
        for port in &analysis.ports {
            if port.number != 22 {  // Skip SSH
                manifests.push_str(&format!("        - containerPort: {}\n", port.number));
                manifests.push_str(&format!("          protocol: {}\n",
                    port.protocol.to_uppercase()));
            }
        }
    }

    // Volume mounts
    if !analysis.volumes.is_empty() {
        manifests.push_str("        volumeMounts:\n");
        for (idx, volume) in analysis.volumes.iter().enumerate() {
            manifests.push_str(&format!("        - name: data-{}\n", idx));
            manifests.push_str(&format!("          mountPath: {}\n", volume.path));
        }
    }

    // Resources
    manifests.push_str("        resources:\n");
    manifests.push_str("          requests:\n");
    manifests.push_str("            memory: \"256Mi\"\n");
    manifests.push_str("            cpu: \"250m\"\n");
    manifests.push_str("          limits:\n");
    manifests.push_str("            memory: \"512Mi\"\n");
    manifests.push_str("            cpu: \"500m\"\n");

    // ConfigMap reference
    manifests.push_str("        envFrom:\n");
    manifests.push_str("        - configMapRef:\n");
    manifests.push_str(&format!("            name: {}-config\n", app_name));

    // Volumes
    if !analysis.volumes.is_empty() {
        manifests.push_str("      volumes:\n");
        for (idx, _volume) in analysis.volumes.iter().enumerate() {
            manifests.push_str(&format!("      - name: data-{}\n", idx));
            manifests.push_str("        persistentVolumeClaim:\n");
            manifests.push_str(&format!("          claimName: {}-data-{}\n", app_name, idx));
        }
    }

    manifests.push_str("\n");

    // Service
    let http_ports: Vec<_> = analysis.ports.iter()
        .filter(|p| p.number != 22)
        .collect();

    if !http_ports.is_empty() {
        manifests.push_str("---\n");
        manifests.push_str("apiVersion: v1\n");
        manifests.push_str("kind: Service\n");
        manifests.push_str("metadata:\n");
        manifests.push_str(&format!("  name: {}\n", app_name));
        manifests.push_str(&format!("  namespace: {}\n", app_name));
        manifests.push_str("spec:\n");
        manifests.push_str("  selector:\n");
        manifests.push_str(&format!("    app: {}\n", app_name));
        manifests.push_str("  ports:\n");

        for port in http_ports {
            manifests.push_str(&format!("  - name: {}\n",
                match port.number {
                    80 => "http",
                    443 => "https",
                    3306 => "mysql",
                    5432 => "postgresql",
                    6379 => "redis",
                    _ => "custom",
                }));
            manifests.push_str(&format!("    port: {}\n", port.number));
            manifests.push_str(&format!("    targetPort: {}\n", port.number));
            manifests.push_str(&format!("    protocol: {}\n", port.protocol.to_uppercase()));
        }

        manifests.push_str("  type: LoadBalancer\n");
        manifests.push_str("\n");

        // Ingress for HTTP/HTTPS
        let has_http = analysis.ports.iter().any(|p| p.number == 80 || p.number == 443);
        if has_http {
            manifests.push_str("---\n");
            manifests.push_str("apiVersion: networking.k8s.io/v1\n");
            manifests.push_str("kind: Ingress\n");
            manifests.push_str("metadata:\n");
            manifests.push_str(&format!("  name: {}\n", app_name));
            manifests.push_str(&format!("  namespace: {}\n", app_name));
            manifests.push_str("  annotations:\n");
            manifests.push_str("    kubernetes.io/ingress.class: nginx\n");
            manifests.push_str("spec:\n");
            manifests.push_str("  rules:\n");
            manifests.push_str(&format!("  - host: {}.example.com\n", app_name));
            manifests.push_str("    http:\n");
            manifests.push_str("      paths:\n");
            manifests.push_str("      - path: /\n");
            manifests.push_str("        pathType: Prefix\n");
            manifests.push_str("        backend:\n");
            manifests.push_str("          service:\n");
            manifests.push_str(&format!("            name: {}\n", app_name));
            manifests.push_str("            port:\n");
            manifests.push_str("              number: 80\n");
        }
    }

    Ok(manifests)
}

fn sanitize_name(name: &str) -> String {
    name.to_lowercase()
        .chars()
        .map(|c| if c.is_alphanumeric() || c == '-' { c } else { '-' })
        .collect()
}
